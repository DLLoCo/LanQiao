# GCD
## 实现:
1. 库函数：

```py
from math import *

gcd(a,b)
```
2. 手写：

~~~py
def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return abs(a)  # 处理负数
~~~

---
## 证明：

### **一、基础准备**
**定义**：设 \( a, b \in \mathbb{Z} \) 且 \( b \neq 0 \)，记 \( d = \gcd(a, b) \)。

**带余除法**：对任意整数 \( a \) 和 \( b \)（\( b > 0 \)），存在唯一整数 \( q \)（商）和 \( r \)（余数），使得：
\[
a = b \cdot q + r \quad \text{且} \quad 0 \leq r < b
\]
其中 \( r = a \mod b \)。


### **二、关键引理**
**引理 1**：若 \( a = b \cdot q + r \)，则 \( \gcd(a, b) = \gcd(b, r) \)。

**证明**：
1. **公约数的传递性**：  
   设 \( d \) 是 \( a \) 和 \( b \) 的公约数，即 \( d \mid a \) 且 \( d \mid b \)。  
   由 \( r = a - b \cdot q \)，得 \( d \mid r \)（因为 \( d \) 整除 \( a \) 和 \( b \)，所以整除它们的线性组合）。  
   因此，\( d \) 是 \( b \) 和 \( r \) 的公约数。

2. **反方向同理**：  
   若 \( d \) 是 \( b \) 和 \( r \) 的公约数，同理可得 \( d \mid a \)。  
   因此，\( a, b \) 的公约数集合与 \( b, r \) 的公约数集合**完全相同**，最大公约数自然相等。


### **三、算法终止性与正确性**
**终止性**：  
每次迭代计算 \( a \mod b \)，余数 \( r \) 满足 \( 0 \leq r < b \)。因此，余数序列严格递减且非负，最终必然在有限步内达到 \( r = 0 \)。

**正确性**：  
当余数 \( r = 0 \) 时，\( \gcd(b, 0) = b \)。根据引理 1，此时 \( b \) 即为原问题的 \( \gcd(a, b) \)。



### **四、数学归纳法证明**
**目标**：证明对任意非负整数 \( a \geq b \)，辗转相除法正确返回 \( \gcd(a, b) \)。

**归纳基础**：  
当 \( b = 0 \) 时，算法直接返回 \( a \)，显然 \( \gcd(a, 0) = a \)。

**归纳假设**：  
假设对所有满足 \( b' < b \) 的正整数，辗转相除法能正确计算 \( \gcd(a', b') \)。

**归纳步骤**：  
对 \( a \) 和 \( b \)（\( b > 0 \)），根据带余除法：  
\[
a = b \cdot q + r \quad (0 \leq r < b)
\]  
由引理 1，\( \gcd(a, b) = \gcd(b, r) \)。  
根据归纳假设，算法能正确计算 \( \gcd(b, r) \)，因此最终结果正确。



### **六、扩展讨论**
1. **负数处理**：  
   \( \gcd(a, b) \) 的定义对负数同样有效，因为 \( \gcd(a, b) = \gcd(|a|, |b|) \)。

2. **时间复杂度**：  
   算法的时间复杂度为 \( O(\log \min(a, b)) \)，因为每次余数

# LCM

## 实现：
1. 手写：
~~~py
def lcm(a,b):
    return a//gcd(a,b)*b
~~~

## 证明：

