# GCD
## 实现:
1. 库函数：

```py
from math import *

gcd(a,b)
```
2. 手写：

~~~py
def gcd(a, b):
    while b != 0:
        a, b = b, a % b
    return abs(a)  # 处理负数
~~~

---
## 证明：

### **一、基础准备**
**定义**：设 \( a, b \in \mathbb{Z} \) 且 \( b \neq 0 \)，记 \( d = \gcd(a, b) \)。

**带余除法**：对任意整数 \( a \) 和 \( b \)（\( b > 0 \)），存在唯一整数 \( q \)（商）和 \( r \)（余数），使得：
\[
a = b \cdot q + r \quad \text{且} \quad 0 \leq r < b
\]
其中 \( r = a \mod b \)。


### **二、关键引理**
**引理 1**：若 \( a = b \cdot q + r \)，则 \( \gcd(a, b) = \gcd(b, r) \)。

**证明**：
1. **公约数的传递性**：  
   设 \( d \) 是 \( a \) 和 \( b \) 的公约数，即 \( d \mid a \) 且 \( d \mid b \)。  
   由 \( r = a - b \cdot q \)，得 \( d \mid r \)（因为 \( d \) 整除 \( a \) 和 \( b \)，所以整除它们的线性组合）。  
   因此，\( d \) 是 \( b \) 和 \( r \) 的公约数。

2. **反方向同理**：  
   若 \( d \) 是 \( b \) 和 \( r \) 的公约数，同理可得 \( d \mid a \)。  
   因此，\( a, b \) 的公约数集合与 \( b, r \) 的公约数集合**完全相同**，最大公约数自然相等。


### **三、算法终止性与正确性**
**终止性**：  
每次迭代计算 \( a \mod b \)，余数 \( r \) 满足 \( 0 \leq r < b \)。因此，余数序列严格递减且非负，最终必然在有限步内达到 \( r = 0 \)。

**正确性**：  
当余数 \( r = 0 \) 时，\( \gcd(b, 0) = b \)。根据引理 1，此时 \( b \) 即为原问题的 \( \gcd(a, b) \)。



### **四、数学归纳法证明**
**目标**：证明对任意非负整数 \( a \geq b \)，辗转相除法正确返回 \( \gcd(a, b) \)。

**归纳基础**：  
当 \( b = 0 \) 时，算法直接返回 \( a \)，显然 \( \gcd(a, 0) = a \)。

**归纳假设**：  
假设对所有满足 \( b' < b \) 的正整数，辗转相除法能正确计算 \( \gcd(a', b') \)。

**归纳步骤**：  
对 \( a \) 和 \( b \)（\( b > 0 \)），根据带余除法：  
\[
a = b \cdot q + r \quad (0 \leq r < b)
\]  
由引理 1，\( \gcd(a, b) = \gcd(b, r) \)。  
根据归纳假设，算法能正确计算 \( \gcd(b, r) \)，因此最终结果正确。



### **六、扩展讨论**
1. **负数处理**：  
   \( \gcd(a, b) \) 的定义对负数同样有效，因为 \( \gcd(a, b) = \gcd(|a|, |b|) \)。

2. **时间复杂度**：  
   算法的时间复杂度为 \( O(\log \min(a, b)) \)，因为每次余数

# LCM

## 实现：
1. 手写：
~~~py
def lcm(a,b):
    return a//gcd(a,b)*b
~~~

## 证明：
### 核心定理
**定理**：\( \text{lcm}(a, b) = \frac{a \cdot b}{\gcd(a, b)} \)。

### 证明过程
#### **步骤 1：分解 \( a \) 和 \( b \)**
设 \( a = d \cdot x \)，\( b = d \cdot y \)，其中 \( x \) 和 \( y \) 互质（即 \( \gcd(x, y) = 1 \)）。  
这是因为 \( d \) 是 \( a \) 和 \( b \) 的最大公约数，所以 \( x \) 和 \( y \) 不能再有公共因子。

#### **步骤 2：推导 LCM 的表达式**
由 LCM 的定义，\( m \) 是同时能被 \( a \) 和 \( b \) 整除的最小正整数。  
根据分解形式：  
\[
m = d \cdot x \cdot y
\]  
这是因为：
- \( m \) 必须包含 \( a \) 的所有因子（即 \( d \cdot x \)），
- 也必须包含 \( b \) 的所有因子（即 \( d \cdot y \)），
- 但 \( x \) 和 \( y \) 互质，所以最小公倍数只需组合 \( d \cdot x \cdot y \)。

#### **步骤 3：建立 LCM 与 GCD 的关系**
由 \( a = d \cdot x \) 和 \( b = d \cdot y \)，代入 LCM 的表达式：  
\[
\text{lcm}(a, b) = d \cdot x \cdot y = \frac{(d \cdot x) \cdot (d \cdot y)}{d} = \frac{a \cdot b}{d}
\]  
即：  
\[
\text{lcm}(a, b) = \frac{a \cdot b}{\gcd(a, b)}
\]

### 严谨性补充
#### **1. 为什么 \( x \) 和 \( y \) 互质？**
- 若 \( \gcd(x, y) = k > 1 \)，则 \( d \cdot k \) 会成为 \( a \) 和 \( b \) 的更大公约数，与 \( d \) 是最大公约数矛盾。

#### **2. 为什么 \( m = d \cdot x \cdot y \) 是最小的公倍数？**
- 任何公倍数必须包含 \( a \) 和 \( b \) 的所有质因子。  
- 由于 \( x \) 和 \( y \) 互质，最小公倍数只需合并 \( a \) 和 \( b \) 的质因子，即 \( d \cdot x \cdot y \)。

### **六、扩展讨论**
#### **1. 负数的处理**
若 \( a \) 或 \( b \) 为负数，取绝对值后公式依然成立：  
\[
\text{lcm}(a, b) = \frac{|a \cdot b|}{\gcd(|a|, |b|)}
\]

#### **2. 多数的 LCM**  
对多个数 \( a_1, a_2, \dots, a_n \)，可通过递归计算：  
\[
\text{lcm}(a_1, a_2, \dots, a_n) = \text{lcm}(\text{lcm}(a_1, a_2), a_3, \dots, a_n)
\]

#### **3. 编程实现中的注意事项**  
- **整数溢出**：计算 \( a \cdot b \) 时可能溢出，建议先计算 \( \frac{a}{\gcd(a, b)} \)，再乘 \( b \)。  
- **Python 代码示例**：  
  ```python
  def lcm(a, b):
      return abs(a) // gcd(a, b) * abs(b)  # 先除后乘避免溢出
  ```

